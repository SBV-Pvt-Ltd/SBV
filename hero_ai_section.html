<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI & ML Services India | Human-AI Collaboration</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* =========================
           THEME VARIABLES
        ========================= */
        :root {
            --bg-main: #0a0a0a;
            --bg-hero1: #0f0f23;
            --bg-hero2: #1a1a2e;
            --overlay1: rgba(10,10,35,.95);
            --overlay2: rgba(26,26,46,.9);
            --overlay3: rgba(15,15,35,.95);
            --text-main: #ffffff;
            --text-muted: #94a3b8;
            --card-bg: rgba(255,255,255,.05);
            --card-border: rgba(255,255,255,.1);
            --accent1: #6366f1;
            --accent2: #8b5cf6;
            --theme-bg-img: linear-gradient(to bottom, #4B0082, #091F92);
        }

        body[data-theme="light"] {
            --bg-main: #f8fafc;
            --bg-hero1: #ffffff;
            --bg-hero2: #eef2ff;
            --overlay1: rgba(255,255,255,.9);
            --overlay2: rgba(245,247,255,.9);
            --overlay3: rgba(255,255,255,.95);
            --text-main: #0f172a;
            --text-muted: #475569;
            --card-bg: rgba(0,0,0,.04);
            --card-border: rgba(0,0,0,.08);
        }

        /* =========================
                   BASE
        ========================= */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box
        }

        body {
            font-family: 'Inter',sans-serif;
            overflow-x: hidden;
            background: var(--bg-main);
            color: var(--text-main);
            transition: background .3s,color .3s;
            background-image: var(--theme-bg-img);
        }

        /* =========================
                   HERO
                ========================= */
        .hero-container {
            position: relative;
            min-height: 100vh;
            overflow: hidden;
            background: linear-gradient(135deg,var(--bg-hero1),var(--bg-hero2));
        }

        .hero-bg, .hero-overlay {
            position: absolute;
            inset: 0
        }

        .hero-bg {
            opacity: .15;
            background: radial-gradient(circle at 30% 50%,rgba(99,102,241,.15),transparent 50%), radial-gradient(circle at 70% 50%,rgba(139,92,246,.15),transparent 50%);
        }

        .hero-overlay {
            background: linear-gradient(135deg, var(--overlay1), var(--overlay2), var(--overlay3));
        }

        .particles {
            position: absolute;
            inset: 0
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle,rgba(99,102,241,.6),transparent);
            animation: float 15s infinite ease-in-out;
        }

            .particle:nth-child(1) {
                width: 80px;
                height: 80px;
                top: 20%;
                left: 10%
            }

            .particle:nth-child(2) {
                width: 60px;
                height: 60px;
                top: 60%;
                left: 80%
            }

            .particle:nth-child(3) {
                width: 100px;
                height: 100px;
                top: 40%;
                left: 60%
            }

            .particle:nth-child(4) {
                width: 70px;
                height: 70px;
                top: 70%;
                left: 20%
            }

        @keyframes float {
            0%,100% {
                transform: translate(0) scale(1);
                opacity: .6
            }

            33% {
                transform: translate(30px,-50px) scale(1.1);
                opacity: .8
            }

            66% {
                transform: translate(-20px,-30px) scale(.9);
                opacity: .5
            }
        }

        /* =========================
                   CONTENT
                ========================= */
        .hero-content {
            position: relative;
            z-index: 10;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem;
        }

        .hero-badge {
            padding: .5rem 1.5rem;
            border-radius: 50px;
            background: rgba(99,102,241,.1);
            border: 1px solid rgba(99,102,241,.3);
            color: var(--accent1);
            margin-bottom: 2rem;
        }

        .hero-title {
            font-size: clamp(2.5rem,8vw,5rem);
            font-weight: 800;
            line-height: 1.1;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg,var(--text-main),var(--accent1));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .hero-subtitle {
            font-size: clamp(1rem,3vw,1.5rem);
            color: var(--text-muted);
            max-width: 700px;
            margin-bottom: 3rem;
        }

        .hero-buttons {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap
        }

        .btn {
            padding: 1rem 2.5rem;
            border-radius: 50px;
            font-weight: 600;
            border: none;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: linear-gradient(135deg,var(--accent1),var(--accent2));
            color: #fff;
        }

        .btn-secondary {
            background: rgba(255,255,255,.15);
            color: var(--text-main);
            border: 2px solid rgba(255,255,255,.2);
        }

        body[data-theme="light"] .btn-secondary {
            background: rgba(0,0,0,.05);
            border: 2px solid rgba(0,0,0,.15);
        }

        /* =========================
                   STATS
                ========================= */
        .hero-stats {
            position: absolute;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4rem;
            z-index: 10;
        }

        .stat-item {
            padding: 1.5rem;
            border-radius: 20px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            text-align: center;
        }

        .stat-number {
            font-size: 2.5rem;
            font-weight: 800;
            background: linear-gradient(135deg,var(--accent1),var(--accent2));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stat-label {
            font-size: .875rem;
            color: var(--text-muted);
        }

        /* =========================
                   TOGGLE
                ========================= */
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            padding: .6rem 1.2rem;
            border-radius: 30px;
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            color: var(--text-main);
            cursor: pointer;
            backdrop-filter: blur(10px);
        }

        /* ========================= */
        #neural-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
            pointer-events: none;
        }

        .mouse-follower {
            position: fixed;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: radial-gradient(circle,rgba(99,102,241,.6),transparent);
            pointer-events: none;
            z-index: 9999;
            filter: blur(10px);
        }



        @media (max-width: 768px) {
            .hero-stats {
                flex-direction: column;
                gap: 1rem;
                bottom: 2%;
            }

            .hero-buttons {
                flex-direction: column;
                width: 100%;
            }

            .btn {
                align-self: center;
                width: 100%;
                max-width: 180px;
            }

            #neural-canvas {
                left: 50%;
                top: 20%;
            }
        }

        @media (max-width: 1024px) {
            #neural-canvas {
                left: 50%;
                top: 50%;
            }
        }

        .mouse-follower {
            position: fixed;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(99, 102, 241, 0.6), transparent);
            pointer-events: none;
            z-index: 9999;
            transition: transform 0.15s ease;
            filter: blur(10px);
        }
    </style>
</head>
<body data-theme="dark" ">
    <button class="theme-toggle">‚òÄÔ∏è Light</button>
    <div class="hero-container">
        <div class="hero-bg"></div>
        <div class="hero-overlay"></div>

        <div class="particles">
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
        </div>

        <canvas id="neural-canvas"></canvas>

        <div class="hero-content">
            <div class="hero-badge">üáÆüá≥ Made in India ‚Ä¢ AI-Powered Solutions</div>

            <h1 class="hero-title">
                Human-AI Collaboration
            </h1>

            <p class="hero-subtitle">
                Empowering businesses with cutting-edge Artificial Intelligence and Machine Learning solutions.
                Experience the future of intelligent automation and data-driven insights.
            </p>

            <div class="hero-buttons">
                <button class="btn btn-primary">Get Started</button>
                <button class="btn btn-secondary">View Demo</button>
            </div>
        </div>
    </div>

    <div class="mouse-follower"></div>

    <script>
        /* ======================
THEME TOGGLE
====================== */
        /* ======================
THEME: AUTO + PERSIST
====================== */
        const body = document.body;
        const toggle = document.querySelector('.theme-toggle');
        const STORAGE_KEY = 'ui-theme';

        /* Apply theme */
        function applyTheme(theme) {
            body.setAttribute('data-theme', theme);
            // toggle.textContent = theme === 'dark' ? '‚òÄÔ∏è Light' : 'üåô Dark';
            if (theme === 'dark') {
                toggle.textContent = '‚òÄÔ∏è Light';
                toggle.style.backgroundColor = "#FFFFFF";
                toggle.style.color = "#000000";

            } else if (theme === 'light') {
                toggle.textContent = 'üåô Dark';
                toggle.style.backgroundColor = "#000000";
                toggle.style.color = "#FFFFFF";
            }
        }

        /* Detect system theme */
        function getSystemTheme() {
            return window.matchMedia('(prefers-color-scheme: dark)').matches
                ? 'dark'
                : 'light';
        }

        /* Init theme */
        (function initTheme() {
            const savedTheme = localStorage.getItem(STORAGE_KEY);
            const theme = savedTheme || getSystemTheme();
            applyTheme(theme);
        })();

        /* Toggle handler */
        toggle.addEventListener('click', () => {
            const current = body.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            localStorage.setItem(STORAGE_KEY, next);
            applyTheme(next);
        });

        /* React to system theme change (only if user hasn't chosen manually) */
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
            if (!localStorage.getItem(STORAGE_KEY)) {
                applyTheme(e.matches ? 'dark' : 'light');
            }
        });
        let scene, camera, renderer, neuralSphere, nodes = [], edges = [];

        function init() {
            const canvas = document.getElementById('neural-canvas');
            scene = new THREE.Scene();

            const width = window.innerWidth < 768 ? 480 : 840;
            const height = window.innerWidth < 768 ? 480 : 840;

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(0, 0, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);

            const ambientLight = new THREE.AmbientLight(0x6366f1, 0.6);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0x8b5cf6, 1.5, 50);
            pointLight1.position.set(5, 5, 5);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x6366f1, 1.2, 50);
            pointLight2.position.set(-5, -5, 5);
            scene.add(pointLight2);

            const pointLight3 = new THREE.PointLight(0xa78bfa, 1.0, 50);
            pointLight3.position.set(0, 0, 10);
            scene.add(pointLight3);

            createNeuralSphere();
            animate();
        }

        function createNeuralSphere() {
            neuralSphere = new THREE.Group();

            const nodeCount = 180;
            const radius = 4;

            const nodeGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const nodeMaterial = new THREE.MeshPhongMaterial({
                color: 0x8b5cf6,
                emissive: 0x6366f1,
                emissiveIntensity: 0.6,
                shininess: 100,
                transparent: true,
                opacity: 0.95
            });

            const glowGeometry = new THREE.SphereGeometry(0.18, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xa78bfa,
                transparent: true,
                opacity: 0.3
            });

            for (let i = 0; i < nodeCount; i++) {
                const phi = Math.acos(-1 + (2 * i) / nodeCount);
                const theta = Math.sqrt(nodeCount * Math.PI) * phi;

                let x = radius * Math.cos(theta) * Math.sin(phi);
                let y = radius * Math.sin(theta) * Math.sin(phi);
                let z = radius * Math.cos(phi);

                // More pronounced human skull shaping
                const normalizedY = y / radius;
                const normalizedX = x / radius;
                const normalizedZ = z / radius;

                // ASYMMETRIC DEFORMATION: Collapse one side
                const sideDeform = x > 0 ? 1.0 : 0.75; // Right side compressed
                x *= sideDeform;

                // CRANIUM: Expand and round the top (brain case)
                if (normalizedY > 0.2) {
                    const craniumExpansion = 1 + (normalizedY * 0.5);
                    x *= craniumExpansion;
                    z *= craniumExpansion;
                    y *= 1.3; // Elongate upward

                    // Additional side deformation on cranium
                    if (x < 0) {
                        x *= 0.85;
                        z *= 0.9;
                    }
                }

                // FACE AREA: Flatten the front
                if (z > 1) {
                    z *= 1.1; // Push face forward
                    if (normalizedY < 0.3 && normalizedY > -0.5) {
                        x *= 0.85; // Narrow face width
                    }
                }

                // JAW: Wider and longer
                if (normalizedY < -0.2) {
                    const jawWidth = Math.max(0.6, 1 - Math.abs(normalizedY + 0.2) * 1.2); // Wider
                    x *= jawWidth * 1.3; // Extra width
                    z *= Math.max(0.7, jawWidth * 1.1); // More depth
                    y -= 0.8; // Drop jaw much lower for length

                    // Side asymmetry on jaw
                    if (x < 0) {
                        x *= 0.8;
                    }
                }

                // CHIN: Wider base
                if (normalizedY < -0.8) {
                    const chinFactor = Math.max(0.4, 1 - Math.abs(normalizedY + 0.8) * 2.5);
                    x *= chinFactor * 1.2; // Wider chin
                    z *= chinFactor * 1.0;
                }

                // EYE SOCKETS: Larger, deeper depressions with gradient depth
                const leftEyeX = 1.5;
                const rightEyeX = -1.5;
                const eyeY = 0.8;
                const eyeZ = 2.5;

                const leftEyeDistance = Math.sqrt(
                    Math.pow(x - leftEyeX, 2) +
                    Math.pow(y - eyeY, 2) +
                    Math.pow(z - eyeZ, 2)
                );
                const rightEyeDistance = Math.sqrt(
                    Math.pow(x - rightEyeX, 2) +
                    Math.pow(y - eyeY, 2) +
                    Math.pow(z - eyeZ, 2)
                );

                // Create deep eye socket depressions
                if (leftEyeDistance < 1.2 || rightEyeDistance < 1.2) {
                    continue; // Skip nodes in eye sockets
                }

                // NASAL CAVITY: Larger triangular nose opening
                if (Math.abs(x) < 0.8 && y > -0.5 && y < 0.7 && z > 2.0 && z < 3.8) {
                    const nasalTaper = Math.abs(y - (-0.5)) / 1.2;
                    if (Math.abs(x) < (0.8 * (1 - nasalTaper * 0.8))) {
                        continue; // Skip nodes in nasal cavity
                    }
                }

                // MOUTH/JAW OPENING: Create open mouth cavity
                if (y < -1.2 && y > -2.5 && z > 1.5 && Math.abs(x) < 1.2) {
                    const mouthDepth = (y + 2.5) / 1.3;
                    const mouthWidth = 1.2 * mouthDepth;
                    if (Math.abs(x) < mouthWidth && z > 1.5 + (1 - mouthDepth) * 0.5) {
                        continue; // Skip nodes in mouth opening
                    }
                }

                // TEETH REGION: Keep some nodes for teeth appearance
                if (y < -1.0 && y > -1.4 && z > 2.2 && z < 2.8 && Math.abs(x) < 1.0) {
                    // This area represents upper teeth row
                    const toothSpacing = Math.abs(Math.sin(x * 8)) > 0.3;
                    if (!toothSpacing) {
                        continue; // Create gaps between teeth
                    }
                }

                // CHEEKBONE: Slight outward curve
                if (normalizedY > 0 && normalizedY < 0.4 && Math.abs(normalizedX) > 0.5 && z > 0) {
                    x *= 1.1;
                }

                // TEMPLE: Narrow temple area
                if (normalizedY > 0.5 && Math.abs(normalizedX) > 0.6) {
                    x *= 0.9;
                }

                // EAR DEPRESSIONS: Create hollow areas on both sides
                const leftEarX = -2.2;
                const rightEarX = 2.2;
                const earY = 0.3;
                const earZ = 0;

                const leftEarDistance = Math.sqrt(
                    Math.pow(x - leftEarX, 2) +
                    Math.pow(y - earY, 2) +
                    Math.pow(z - earZ, 2)
                );
                const rightEarDistance = Math.sqrt(
                    Math.pow(x - rightEarX, 2) +
                    Math.pow(y - earY, 2) +
                    Math.pow(z - earZ, 2)
                );

                // Remove nodes in ear regions to create depressions
                if (leftEarDistance < 0.9 || rightEarDistance < 0.9) {
                    continue; // Skip nodes in ear areas
                }

                const node = new THREE.Mesh(nodeGeometry, nodeMaterial.clone());
                node.position.set(x, y, z);

                // Depth-based scaling: larger nodes in front (higher z), smaller in back
                const depthFactor = (z + radius) / (radius * 2); // 0 to 1 range
                const scale = 0.4 + (depthFactor * 1.2); // Range from 0.4x to 1.6x
                node.scale.set(scale, scale, scale);

                const glow = new THREE.Mesh(glowGeometry, glowMaterial.clone());
                glow.position.copy(node.position);
                glow.scale.set(scale, scale, scale);

                neuralSphere.add(node);
                neuralSphere.add(glow);

                nodes.push({
                    mesh: node,
                    glow: glow,
                    position: new THREE.Vector3(x, y, z),
                    phase: Math.random() * Math.PI * 2
                });
            }

            const edgeMaterial = new THREE.LineBasicMaterial({
                color: 0x8b5cf6,
                transparent: true,
                opacity: 0.35,
                linewidth: 2
            });

            for (let i = 0; i < nodes.length; i++) {
                const connectionCount = Math.floor(Math.random() * 4) + 3;

                for (let j = 0; j < connectionCount; j++) {
                    const targetIndex = Math.floor(Math.random() * nodes.length);
                    if (targetIndex !== i) {
                        const distance = nodes[i].position.distanceTo(nodes[targetIndex].position);

                        if (distance < radius * 1.2) {
                            const points = [
                                nodes[i].position.clone(),
                                nodes[targetIndex].position.clone()
                            ];
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const line = new THREE.Line(geometry, edgeMaterial.clone());

                            neuralSphere.add(line);
                            edges.push({
                                line: line,
                                material: line.material,
                                phase: Math.random() * Math.PI * 2
                            });
                        }
                    }
                }
            }

            const wireframeGeometry = new THREE.SphereGeometry(radius * 1.05, 32, 32);
            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x6366f1,
                wireframe: true,
                transparent: true,
                opacity: 0.05
            });
            const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);

            // Apply realistic face deformation to wireframe
            const positions = wireframe.geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                let x = positions.getX(i);
                let y = positions.getY(i);
                let z = positions.getZ(i);

                const normalizedY = y / radius;
                const normalizedX = x / radius;

                // Forehead
                if (normalizedY > 0.7) {
                    const foreheadCurve = 1 + (normalizedY - 0.7) * 0.5;
                    x *= foreheadCurve * 0.98;
                    z *= foreheadCurve * 1.02;
                    y *= 1.12;
                }

                // Upper head
                if (normalizedY > 0.4 && normalizedY <= 0.7) {
                    const headExpansion = 1 + (normalizedY * 0.3);
                    x *= headExpansion * 1.05;
                    z *= headExpansion * 0.95;
                    y *= 1.15;
                }

                // Temples
                if (normalizedY > 0.3 && normalizedY <= 0.5 && Math.abs(normalizedX) > 0.6) {
                    x *= 0.93;
                }

                // Upper face
                if (normalizedY > 0.1 && normalizedY <= 0.4) {
                    z *= 1.08;
                    x *= 0.96;
                }

                // Cheekbones
                if (normalizedY > -0.05 && normalizedY < 0.25 && Math.abs(normalizedX) > 0.35 && z > 1.5) {
                    x *= 1.12;
                    z *= 1.06;
                }

                // Mid-face
                if (normalizedY > -0.2 && normalizedY <= 0.1 && z > 1.5) {
                    z *= 1.05;
                    x *= 0.94;
                }

                // Jaw
                if (normalizedY < -0.1 && normalizedY > -0.5) {
                    const jawTaper = 1 - (Math.abs(normalizedY + 0.1) * 0.5);
                    x *= jawTaper * 0.92;
                    z *= jawTaper * 0.96;
                    y -= 0.05;
                }

                // Chin
                if (normalizedY < -0.5 && normalizedY > -0.75) {
                    const chinRound = Math.max(0.45, 1 - Math.abs(normalizedY + 0.5) * 2);
                    x *= chinRound * 0.68;
                    z *= chinRound * 0.88;
                    y -= 0.15;
                }

                // Neck
                if (normalizedY < -0.75) {
                    const neckNarrow = Math.max(0.35, 1 - Math.abs(normalizedY + 0.75) * 2.5);
                    x *= neckNarrow * 0.75;
                    z *= neckNarrow * 0.7;
                }

                positions.setXYZ(i, x, y, z);
            }
            positions.needsUpdate = true;

            neuralSphere.add(wireframe);

            scene.add(neuralSphere);
        }

        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            neuralSphere.rotation.y += 0.003;
            neuralSphere.rotation.x = Math.sin(time * 0.3) * 0.05;

            nodes.forEach((node, i) => {
                const scale = 1 + Math.sin(time * 2 + node.phase) * 0.3;
                node.mesh.scale.set(scale, scale, scale);

                const glowScale = 1 + Math.sin(time * 2 + node.phase + 0.5) * 0.5;
                node.glow.scale.set(glowScale, glowScale, glowScale);

                const intensity = 0.3 + Math.sin(time * 3 + node.phase) * 0.4;
                node.mesh.material.emissiveIntensity = intensity;
            });

            edges.forEach((edge, i) => {
                const opacity = 0.1 + Math.sin(time * 2 + edge.phase) * 0.15;
                edge.material.opacity = Math.max(0.05, opacity);
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('load', init);

        window.addEventListener('resize', () => {
            const width = window.innerWidth < 768 ? 480 : 840;
            const height = window.innerWidth < 768 ? 480 : 840;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

        const mouseFollower = document.querySelector('.mouse-follower');
        document.addEventListener('mousemove', (e) => {
            mouseFollower.style.left = e.clientX + 'px';
            mouseFollower.style.top = e.clientY + 'px';
        });

        const heroContent = document.querySelector('.hero-content');
        const particles = document.querySelectorAll('.particle');

        document.addEventListener('mousemove', (e) => {
            const x = (e.clientX / window.innerWidth) - 0.5;
            const y = (e.clientY / window.innerHeight) - 0.5;

            heroContent.style.transform = `translate(${x * 20}px, ${y * 20}px)`;

            particles.forEach((particle, index) => {
                const speed = (index + 1) * 10;
                particle.style.transform = `translate(${x * speed}px, ${y * speed}px)`;
            });

            if (neuralSphere) {
                const rotationX = -y * 0.5;
                const rotationY = x * 0.5;
                neuralSphere.rotation.x += (rotationX - neuralSphere.rotation.x) * 0.05;
                neuralSphere.rotation.y += (rotationY - neuralSphere.rotation.y) * 0.05;
            }
        });

        const observerOptions = {
            threshold: 0.5,
            rootMargin: '0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    animateStats();
                    observer.unobserve(entry.target);
                }
            });
        }, observerOptions);

        const statsSection = document.querySelector('.hero-stats');
        if (statsSection) {
            observer.observe(statsSection);
        }

        function animateStats() {
            const statNumbers = document.querySelectorAll('.stat-number');

            statNumbers.forEach(stat => {
                const finalValue = stat.textContent;
                const isPercentage = finalValue.includes('%');
                const isTime = finalValue.includes('/');
                let numValue = parseInt(finalValue);

                if (isNaN(numValue)) return;

                let currentValue = 0;
                const increment = numValue / 50;
                const duration = 2000;
                const stepTime = duration / 50;

                const counter = setInterval(() => {
                    currentValue += increment;
                    if (currentValue >= numValue) {
                        stat.textContent = finalValue;
                        clearInterval(counter);
                    } else {
                        if (isPercentage) {
                            stat.textContent = Math.floor(currentValue) + '%';
                        } else if (isTime) {
                            stat.textContent = '24/7';
                        } else {
                            stat.textContent = Math.floor(currentValue) + '+';
                        }
                    }
                }, stepTime);
            });
        }

        const buttons = document.querySelectorAll('.btn');
        buttons.forEach(button => {
            button.addEventListener('click', function (e) {
                const ripple = document.createElement('span');
                ripple.style.position = 'absolute';
                ripple.style.borderRadius = '50%';
                ripple.style.background = 'rgba(255, 255, 255, 0.6)';
                ripple.style.width = '20px';
                ripple.style.height = '20px';
                ripple.style.left = e.offsetX + 'px';
                ripple.style.top = e.offsetY + 'px';
                ripple.style.pointerEvents = 'none';
                ripple.style.animation = 'ripple 0.6s ease-out';

                this.appendChild(ripple);

                setTimeout(() => {
                    ripple.remove();
                }, 600);
            });
        });

        const style = document.createElement('style');
        style.textContent = `
                        @keyframes ripple {
                            to {
                                transform: scale(20);
                                opacity: 0;
                            }
                        }
                    `;
        document.head.appendChild(style);

        document.querySelectorAll('.btn-secondary').forEach(btn => {
            btn.addEventListener('click', () => {
                alert('Demo section coming soon! üöÄ');
            });
        });

        document.querySelectorAll('.btn-primary').forEach(btn => {
            btn.addEventListener('click', () => {
                alert('Contact us at: contact@aimlservices.in üìß');
            });
        });
    </script>
</body>
</html>